#! /usr/bin/env python3

import argparse
from os import (chdir, getcwd, makedirs, path)
from subprocess import call
from sys import argv
from typing import (Callable, cast)


# This has to be done to simulate a constant, immutable value
def VERSION() -> str: return '1.4'


class Args:
  noGitignore: bool
  noReq: bool
  venvDir: str
  displayVersion: bool
  projectDir: str


def parseArgs() -> Args:
  parser = argparse.ArgumentParser(
    description = 'Automate creation of virtual environments in Python 3 projects',
    formatter_class = argparse.RawDescriptionHelpFormatter,
    epilog = f"""
Creates a Python virtual environment directory in a new or existing project
using `python3 -m venv`. After the environment is created, this tool will
update `pip`, `setuptools` and `wheel`. Finally, it will detect a
`requirements.txt` file and `pip install -r` it.

This tool will also create a `.gitignore` file if none is present.

After your environment is created, don't forget to activate

  $ . ./.venv/bin/activate

If you add more packages, consider refreshing the `requirements.txt` file

  $ pip install SOME_PYTHON_PACKAGE
  $ pip freeze > requirements.txt

To leave the environment, deactivate

  $ deactivate

v{VERSION()}  Dino Morelli <dino@ui3.info>"""
    )

  parser.add_argument(
    '-G', '--no-gitignore',
    dest = 'noGitignore',
    action = 'store_true',
    help = "Suppress creation of `.gitignore` file"
    )

  parser.add_argument(
    '-R', '--no-req',
    dest = 'noReq',
    action = 'store_true',
    help = "Suppress installation of dependencies in `requirements.txt`"
    )

  venvDefault = '.venv'
  parser.add_argument(
    '-v', '--venv-dir',
    dest = 'venvDir',
    metavar = 'DIR',
    default = venvDefault,
    help = f"Directory under the project to create the virtual environment [default: {venvDefault}]"
    )

  parser.add_argument(
    '--version',
    dest = 'displayVersion',
    action = 'store_true',
    help = "Show version info and exit"
    )

  projectDirDefault = '.'
  parser.add_argument(
    'projectDir',
    metavar = 'PROJECT_DIR',
    nargs = '?',
    default = projectDirDefault,
    help = f"Project directory, specifying this will create a new project directory and environment within it [default: {projectDirDefault}]"
    )

  return cast(Args, parser.parse_args())


# Execute a function only if we can chdir into the supplied directory first.
# Restoring the working directory afterwards.
def withDirectory(directory: str, f: Callable[[], None]) -> None:
  cwd = getcwd()

  try:
    chdir(directory)
    f()
  finally:
    chdir(cwd)


def prepDirectory(projectDir: str) -> None:
  if not path.exists(projectDir):
    makedirs(projectDir)


def mkVirtEnv(venvDir: str, noReq: bool) -> Callable[[], None]:
  def f() -> None:
    call(['python3', '-m', 'venv', venvDir])
    call([f'{venvDir}/bin/python', '-m', 'pip', 'install',
      '--upgrade', 'pip', 'setuptools', 'wheel'])

    reqFile = 'requirements.txt'

    if not path.exists(reqFile):
      print(f'No {reqFile} found')
    elif noReq:
      print('Installation of requirements not desired')
    else:
      call([f'{venvDir}/bin/pip', 'install', '-r', reqFile])

  return f


def mkGitignore(venvDir: str, noGitignore: bool) -> Callable[[], None]:
  def f() -> None:
    gitIgnoreFile = '.gitignore'

    if path.exists(gitIgnoreFile):
      print(f'{gitIgnoreFile} already exists, not creating')
    elif noGitignore:
      print(f'No {gitIgnoreFile} desired, not creating')
    else:
      with open(gitIgnoreFile, 'w') as f:
        f.write(f'{venvDir}\n')
      print(f'{gitIgnoreFile} created')

  return f


def main() -> None:
  args = parseArgs()

  if args.displayVersion:
    print(f"{argv[0]} {VERSION()}")
  else:
    prepDirectory(args.projectDir)
    withDirectory(args.projectDir, mkVirtEnv(args.venvDir, args.noReq))
    withDirectory(args.projectDir, mkGitignore(args.venvDir, args.noGitignore))
    print(f"\nVirtual environment is ready for project in directory {args.projectDir}")


if __name__ == '__main__': main()
